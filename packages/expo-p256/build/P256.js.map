{"version":3,"file":"P256.js","sourceRoot":"","sources":["../src/P256.ts"],"names":[],"mappings":"AAEA,OAAO,EAAE,MAAM,EAAE,MAAM,IAAI,CAAA;AAC3B,OAAO,QAAQ,MAAM,YAAY,CAAA;AACjC,OAAO,EAIL,gCAAgC,EAChC,6BAA6B,EAC7B,kCAAkC,EAClC,sBAAsB,EACtB,cAAc,EACd,kBAAkB,GACnB,MAAM,kBAAkB,CAAA;AAEzB,wCAAwC;AAExC,MAAM,CAAC,MAAM,UAAU,GAAG,gBAAgB,CAAA;AAE1C,qCAAqC;AAErC,4EAA4E;AAC5E,MAAM,OAAO,wBAAyB,SAAQ,MAAM,CAAC,SAAS;IAC1C,IAAI,GAAG,+BAA+B,CAAA;IAExD;QACE,KAAK,CAAC,kDAAkD,CAAC,CAAA;IAC3D,CAAC;CACF;AAED,0EAA0E;AAC1E,MAAM,OAAO,4BAA6B,SAAQ,MAAM,CAAC,SAAS;IAC9C,IAAI,GAAG,mCAAmC,CAAA;IAE5D;QACE,KAAK,CAAC,0DAA0D,CAAC,CAAA;IACnE,CAAC;CACF;AAsCD,wCAAwC;AAExC;;;;GAIG;AACH,MAAM,CAAC,MAAM,kBAAkB,GAC7B,QAAQ,CAAC,kBAAkB,CAAA;AAE7B;;;GAGG;AACH,MAAM,CAAC,MAAM,mCAAmC,GAC9C,QAAQ,CAAC,mCAAmC,CAAA;AAE9C;;;;GAIG;AACH,MAAM,CAAC,MAAM,MAAM,GAAkC,QAAQ,CAAC,MAAM,CAAA;AAEpE;;;GAGG;AACH,MAAM,CAAC,MAAM,kCAAkC,GAC7C,QAAQ,CAAC,kCAAkC,CAAA;AAE7C;;;GAGG;AACH,MAAM,CAAC,MAAM,uBAAuB,GAClC,QAAQ,CAAC,uBAAuB,CAAA;AAElC;;GAEG;AACH,MAAM,CAAC,MAAM,aAAa,GACxB,QAAQ,CAAC,aAAa,CAAA;AAExB;;;GAGG;AACH,MAAM,CAAC,MAAM,8BAA8B,GACzC,QAAQ,CAAC,8BAA8B,CAAA;AAEzC,6CAA6C;AAE7C;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA4BG;AACH,MAAM,CAAC,KAAK,UAAU,aAAa,CACjC,UAAiC,EAAE;IAEnC,IAAI,CAAC,CAAC,MAAM,gBAAgB,EAAE,CAAC,EAAE,CAAC;QAChC,MAAM,IAAI,wBAAwB,EAAE,CAAA;IACtC,CAAC;IAED,IAAI,OAAO,CAAC,qBAAqB,IAAI,CAAC,6BAA6B,EAAE,EAAE,CAAC;QACtE,MAAM,IAAI,4BAA4B,EAAE,CAAA;IAC1C,CAAC;IAED,MAAM,UAAU,GAAG,kBAAkB,EAAE,CAAA;IACvC,MAAM,cAAc,GAAG,MAAM,QAAQ,CAAC,iBAAiB,CAAC,UAAU,EAAE,OAAO,CAAC,CAAA;IAC5E,OAAO,gCAAgC,CAAC,UAAU,EAAE,cAAc,CAAC,CAAA;AACrE,CAAC;AAsBD;;;;;;;GAOG;AACH,MAAM,CAAC,KAAK,UAAU,UAAU,CAC9B,OAA2B;IAE3B,IAAI,CAAC,CAAC,MAAM,gBAAgB,EAAE,CAAC,EAAE,CAAC;QAChC,MAAM,IAAI,wBAAwB,EAAE,CAAA;IACtC,CAAC;IAED,IAAI,OAAO,CAAC,qBAAqB,IAAI,CAAC,6BAA6B,EAAE,EAAE,CAAC;QACtE,MAAM,IAAI,4BAA4B,EAAE,CAAA;IAC1C,CAAC;IAED,MAAM,EAAE,oBAAoB,EAAE,GAAG,WAAW,EAAE,GAAG,OAAO,CAAA;IACxD,cAAc,CAAC,oBAAoB,CAAC,CAAA;IACpC,MAAM,cAAc,GAAG,MAAM,QAAQ,CAAC,cAAc,CAClD,oBAAoB,EACpB,WAAW,CACZ,CAAA;IACD,OAAO,6BAA6B,CAAC,oBAAoB,EAAE,cAAc,CAAC,CAAA;AAC5E,CAAC;AAyBD;;;;;;;;;;;;;;;;;;;;;GAqBG;AACH,MAAM,CAAC,KAAK,UAAU,IAAI,CAAC,OAAqB;IAC9C,IAAI,CAAC,CAAC,MAAM,gBAAgB,EAAE,CAAC,EAAE,CAAC;QAChC,MAAM,IAAI,wBAAwB,EAAE,CAAA;IACtC,CAAC;IAED,IAAI,OAAO,CAAC,qBAAqB,IAAI,CAAC,6BAA6B,EAAE,EAAE,CAAC;QACtE,MAAM,IAAI,4BAA4B,EAAE,CAAA;IAC1C,CAAC;IAED,MAAM,EAAE,oBAAoB,EAAE,OAAO,EAAE,GAAG,WAAW,EAAE,GAAG,OAAO,CAAA;IACjE,cAAc,CAAC,oBAAoB,CAAC,CAAA;IACpC,MAAM,aAAa,GAAG,sBAAsB,CAAC,OAAO,CAAC,CAAA;IACrD,MAAM,cAAc,GAAG,MAAM,QAAQ,CAAC,mBAAmB,CACvD,oBAAoB,EACpB,aAAa,EACb,WAAW,CACZ,CAAA;IAED,OAAO,kCAAkC,CAAC,cAAc,CAAC,CAAA;AAC3D,CAAC;AA2BD;;;;;;;;;;;;;;;;GAgBG;AACH,MAAM,CAAC,KAAK,UAAU,MAAM,CAC1B,OAAuB;IAEvB,IAAI,CAAC,CAAC,MAAM,gBAAgB,EAAE,CAAC,EAAE,CAAC;QAChC,MAAM,IAAI,wBAAwB,EAAE,CAAA;IACtC,CAAC;IAED,MAAM,EAAE,SAAS,EAAE,SAAS,EAAE,OAAO,EAAE,GAAG,OAAO,CAAA;IACjD,OAAO,MAAM,QAAQ,CAAC,mBAAmB,CACvC,SAAS,EACT,SAAS,EACT,OAAO,EACP,OAAO,CACR,CAAA;AACH,CAAC;AAmBD;;;;;GAKG;AACH,MAAM,CAAC,KAAK,UAAU,gBAAgB;IACpC,OAAO,CAAC,CAAC,QAAQ,CAAC,iBAAiB,CAAA;AACrC,CAAC;AAED;;;;;GAKG;AACH,MAAM,CAAC,KAAK,UAAU,eAAe,CACnC,GAAW,EACX,UAAuB,EAAE;IAEzB,MAAM,QAAQ,CAAC,uBAAuB,CAAC,GAAG,EAAE,OAAO,CAAC,CAAA;AACtD,CAAC;AAED;;;;;;;GAOG;AACH,MAAM,UAAU,6BAA6B;IAC3C,OAAO,QAAQ,CAAC,6BAA6B,EAAE,CAAA;AACjD,CAAC","sourcesContent":["import type { PublicKey, Signature } from 'ox'\nimport type { Bytes, Hex } from 'ox'\nimport { Errors } from 'ox'\nimport ExpoP256 from './ExpoP256'\nimport {\n  type InvalidKeyFormatError,\n  type InvalidKeyPairError,\n  type InvalidSignatureError,\n  adaptCreateP256KeyPairReturnType,\n  adaptGetP256KeyPairReturnType,\n  adaptSignWithP256KeyPairReturnType,\n  convertPayloadToBase64,\n  ensureValidKey,\n  generateStorageKey,\n} from './internal/utils'\n\n// ============= Constants =============\n\nexport const KEY_PREFIX = 'porto-p256-key'\n\n// ============= Errors =============\n\n/** Thrown when P256 operations are attempted on an unsupported platform. */\nexport class UnsupportedPlatformError extends Errors.BaseError {\n  override readonly name = 'P256.UnsupportedPlatformError'\n\n  constructor() {\n    super('P256 operations are not supported on this device')\n  }\n}\n\n/** Thrown when biometric authentication is required but not available. */\nexport class BiometricAuthenticationError extends Errors.BaseError {\n  override readonly name = 'P256.BiometricAuthenticationError'\n\n  constructor() {\n    super('Biometric authentication is not available on this device')\n  }\n}\n\n// ============= Types =============\n\nexport type KeychainAccessibilityConstant = number\n\n/**\n * Options for P256 key operations.\n */\nexport type P256Options = {\n  /**\n   * - Android: Equivalent of the public/private key pair `Alias`.\n   * - iOS: The item's service, equivalent to [`kSecAttrService`](https://developer.apple.com/documentation/security/ksecattrservice/).\n   * > If the item is set with the `keychainService` option, it will be required to later fetch the value.\n   */\n  keychainService?: string\n  /**\n   * Option responsible for enabling the usage of the user authentication methods available on the device while\n   * signing with a P256 key.\n   * - Android: Equivalent to [`setUserAuthenticationRequired(true)`](https://developer.android.com/reference/android/security/keystore/KeyGenParameterSpec.Builder#setUserAuthenticationRequired(boolean))\n   *   (requires API 23).\n   * - iOS: Equivalent to [`biometryCurrentSet`](https://developer.apple.com/documentation/security/secaccesscontrolcreateflags/2937192-biometrycurrentset).\n   * Note: Authentication requirements are determined at key creation time and cannot be modified afterwards.\n   */\n  requireAuthentication?: boolean\n  /**\n   * Custom message displayed to the user while `requireAuthentication` option is turned on.\n   */\n  authenticationPrompt?: string\n  /**\n   * Specifies when the stored entry is accessible, using iOS's `kSecAttrAccessible` property.\n   * @see Apple's documentation on [keychain item accessibility](https://developer.apple.com/documentation/security/ksecattraccessible/).\n   * @default P256.WHEN_UNLOCKED\n   * @platform ios\n   */\n  keychainAccessible?: KeychainAccessibilityConstant\n}\n\n// ============= Constants =============\n\n/**\n * The data in the keychain item cannot be accessed after a restart until the device has been\n * unlocked once by the user. This may be useful if you need to access the item when the phone\n * is locked.\n */\nexport const AFTER_FIRST_UNLOCK: KeychainAccessibilityConstant =\n  ExpoP256.AFTER_FIRST_UNLOCK\n\n/**\n * Similar to `AFTER_FIRST_UNLOCK`, except the entry is not migrated to a new device when restoring\n * from a backup.\n */\nexport const AFTER_FIRST_UNLOCK_THIS_DEVICE_ONLY: KeychainAccessibilityConstant =\n  ExpoP256.AFTER_FIRST_UNLOCK_THIS_DEVICE_ONLY\n\n/**\n * The data in the keychain item can always be accessed regardless of whether the device is locked.\n * This is the least secure option.\n * @deprecated Use an accessibility level that provides some user protection, such as `AFTER_FIRST_UNLOCK`.\n */\nexport const ALWAYS: KeychainAccessibilityConstant = ExpoP256.ALWAYS\n\n/**\n * Similar to `WHEN_UNLOCKED_THIS_DEVICE_ONLY`, except the user must have set a passcode in order to\n * store an entry. If the user removes their passcode, the entry will be deleted.\n */\nexport const WHEN_PASSCODE_SET_THIS_DEVICE_ONLY: KeychainAccessibilityConstant =\n  ExpoP256.WHEN_PASSCODE_SET_THIS_DEVICE_ONLY\n\n/**\n * Similar to `ALWAYS`, except the entry is not migrated to a new device when restoring from a backup.\n * @deprecated Use an accessibility level that provides some user protection, such as `AFTER_FIRST_UNLOCK_THIS_DEVICE_ONLY`.\n */\nexport const ALWAYS_THIS_DEVICE_ONLY: KeychainAccessibilityConstant =\n  ExpoP256.ALWAYS_THIS_DEVICE_ONLY\n\n/**\n * The data in the keychain item can be accessed only while the device is unlocked by the user.\n */\nexport const WHEN_UNLOCKED: KeychainAccessibilityConstant =\n  ExpoP256.WHEN_UNLOCKED\n\n/**\n * Similar to `WHEN_UNLOCKED`, except the entry is not migrated to a new device when restoring from\n * a backup.\n */\nexport const WHEN_UNLOCKED_THIS_DEVICE_ONLY: KeychainAccessibilityConstant =\n  ExpoP256.WHEN_UNLOCKED_THIS_DEVICE_ONLY\n\n// ============= Core Functions =============\n\n/**\n * Creates a P256 key pair and stores it securely.\n *\n * Platform Implementation Details:\n * - iOS:\n *   - The private key is generated and stored in the Secure Enclave\n *   - A reference to this key is stored in the Keychain\n *   - If requireAuthentication is true, the key is created with `.userPresence` flag\n *   - Authentication and NSFaceIDUsageDescription is required for signing if `requireAuthentication` is true\n *\n * - Android:\n *   - The key pair is generated and stored directly in the Android Keystore System\n *   - If requireAuthentication is true, the authentication requirement is permanently bound to the key\n *   - This affects all subsequent operations with this key\n *\n * @example\n * ```ts\n * const { publicKey, privateKeyStorageKey } = await P256.createKeyPair({\n *   requireAuthentication: true,\n *   authenticationPrompt: \"Please authenticate to create a key pair\"\n * })\n * ```\n *\n * @param options - Configuration options for key pair creation\n * @returns Promise resolving to the key pair\n * @throws {UnsupportedPlatformError} When P256 operations are not supported\n * @throws {InvalidKeyPairError} When key pair creation fails\n * @throws {BiometricAuthenticationError} When biometric authentication is required but not available\n */\nexport async function createKeyPair(\n  options: createKeyPair.Options = {},\n): Promise<createKeyPair.ReturnType> {\n  if (!(await isAvailableAsync())) {\n    throw new UnsupportedPlatformError()\n  }\n\n  if (options.requireAuthentication && !canUseBiometricAuthentication()) {\n    throw new BiometricAuthenticationError()\n  }\n\n  const storageKey = generateStorageKey()\n  const nativeResponse = await ExpoP256.createP256KeyPair(storageKey, options)\n  return adaptCreateP256KeyPairReturnType(storageKey, nativeResponse)\n}\n\nexport declare namespace createKeyPair {\n  type Options = P256Options\n\n  type NativeResponse = {\n    privateKey: string\n    publicKey: string\n  }\n\n  type ReturnType = {\n    privateKeyStorageKey: string\n    publicKey: PublicKey.PublicKey\n  }\n\n  type ErrorType =\n    | UnsupportedPlatformError\n    | InvalidKeyPairError\n    | BiometricAuthenticationError\n    | Errors.GlobalErrorType\n}\n\n/**\n * Retrieves a stored P256 key pair.\n *\n * @throws {UnsupportedPlatformError} When P256 operations are not supported\n * @throws {InvalidKeyFormatError} When the storage key format is invalid\n * @throws {InvalidKeyPairError} When the key pair cannot be retrieved\n * @throws {BiometricAuthenticationError} When biometric authentication is required but not available\n */\nexport async function getKeyPair(\n  options: getKeyPair.Options,\n): Promise<getKeyPair.ReturnType> {\n  if (!(await isAvailableAsync())) {\n    throw new UnsupportedPlatformError()\n  }\n\n  if (options.requireAuthentication && !canUseBiometricAuthentication()) {\n    throw new BiometricAuthenticationError()\n  }\n\n  const { privateKeyStorageKey, ...p256Options } = options\n  ensureValidKey(privateKeyStorageKey)\n  const nativeResponse = await ExpoP256.getP256KeyPair(\n    privateKeyStorageKey,\n    p256Options,\n  )\n  return adaptGetP256KeyPairReturnType(privateKeyStorageKey, nativeResponse)\n}\n\nexport declare namespace getKeyPair {\n  type Options = P256Options & {\n    privateKeyStorageKey: string\n  }\n\n  type NativeResponse = {\n    privateKey: string\n    publicKey: string\n  } | null\n\n  type ReturnType = {\n    privateKeyStorageKey: string\n    publicKey: PublicKey.PublicKey\n  } | null\n\n  type ErrorType =\n    | UnsupportedPlatformError\n    | InvalidKeyFormatError\n    | InvalidKeyPairError\n    | BiometricAuthenticationError\n    | Errors.GlobalErrorType\n}\n\n/**\n * Signs data using a stored P256 key pair.\n *\n * Note: If the key was created with requireAuthentication=true, this operation will\n * require user authentication regardless of the options passed to this function.\n *\n * @example\n * ```ts\n * const signature = await P256.sign({\n *   privateKeyStorageKey: \"stored-key-reference\",\n *   payload: \"0xdeadbeef\",\n *   requireAuthentication: true\n * })\n * ```\n *\n * @param options - Signing options including key, payload, and authentication settings\n * @returns Promise resolving to the signature\n * @throws {UnsupportedPlatformError} When P256 operations are not supported\n * @throws {InvalidKeyFormatError} When the storage key format is invalid\n * @throws {InvalidSignatureError} When signing fails\n * @throws {BiometricAuthenticationError} When biometric authentication is required but not available\n */\nexport async function sign(options: sign.Options): Promise<sign.ReturnType> {\n  if (!(await isAvailableAsync())) {\n    throw new UnsupportedPlatformError()\n  }\n\n  if (options.requireAuthentication && !canUseBiometricAuthentication()) {\n    throw new BiometricAuthenticationError()\n  }\n\n  const { privateKeyStorageKey, payload, ...p256Options } = options\n  ensureValidKey(privateKeyStorageKey)\n  const base64Payload = convertPayloadToBase64(payload)\n  const nativeResponse = await ExpoP256.signWithP256KeyPair(\n    privateKeyStorageKey,\n    base64Payload,\n    p256Options,\n  )\n\n  return adaptSignWithP256KeyPairReturnType(nativeResponse)\n}\n\nexport declare namespace sign {\n  /** Options for signing data with a P256 key pair */\n  type Options = P256Options & {\n    /** Storage key referencing the private key in secure storage */\n    privateKeyStorageKey: string\n    /** Data to sign in either hex or bytes format */\n    payload: Hex.Hex | Bytes.Bytes\n  }\n  /** Raw response from native module */\n  type NativeResponse = {\n    /** Base64 encoded signature bytes */\n    signature: string\n    /** DER encoded public key */\n    publicKey: string\n  } | null\n  /** Matches WebCryptoP256.sign return type */\n  type ReturnType = Signature.Signature<false>\n  type ErrorType =\n    | UnsupportedPlatformError\n    | InvalidKeyFormatError\n    | InvalidSignatureError\n    | BiometricAuthenticationError\n    | Errors.GlobalErrorType\n}\n\n/**\n * Verifies a signature using a P256 public key.\n *\n * @example\n * ```ts\n * const isValid = await P256.verify({\n *   publicKey: publicKeyDER,\n *   signature: signatureBase64,\n *   payload: \"0xdeadbeef\"\n * })\n * ```\n *\n * @param options - Verification options including public key, signature, and payload\n * @returns Promise resolving to boolean indicating validity\n * @throws {UnsupportedPlatformError} When P256 operations are not supported\n * @throws {InvalidSignatureError} When verification fails due to invalid signature format\n */\nexport async function verify(\n  options: verify.Options,\n): Promise<verify.ReturnType> {\n  if (!(await isAvailableAsync())) {\n    throw new UnsupportedPlatformError()\n  }\n\n  const { publicKey, signature, payload } = options\n  return await ExpoP256.verifyP256Signature(\n    publicKey,\n    signature,\n    payload,\n    options,\n  )\n}\n\nexport declare namespace verify {\n  type Options = P256Options & {\n    /** DER encoded public key */\n    publicKey: string\n    /** Base64 encoded signature */\n    signature: string\n    /** Data that was signed */\n    payload: string\n  }\n  /** Matches WebCryptoP256.verify return type */\n  type ReturnType = boolean\n  type ErrorType =\n    | UnsupportedPlatformError\n    | InvalidSignatureError\n    | Errors.GlobalErrorType\n}\n\n/**\n * Checks if P256 operations are available on the current device.\n * This does not check app permissions.\n *\n * @returns Promise resolving to boolean indicating availability\n */\nexport async function isAvailableAsync(): Promise<boolean> {\n  return !!ExpoP256.createP256KeyPair\n}\n\n/**\n * Deletes a stored key pair.\n *\n * @param key - Storage key of the key pair to delete\n * @param options - Optional configuration\n */\nexport async function deleteItemAsync(\n  key: string,\n  options: P256Options = {},\n): Promise<void> {\n  await ExpoP256.deleteValueWithKeyAsync(key, options)\n}\n\n/**\n * Checks if biometric authentication can be used for P256 operations.\n * Returns false on tvOS.\n *\n * @platform android\n * @platform ios\n * @returns boolean indicating if biometric authentication is available\n */\nexport function canUseBiometricAuthentication(): boolean {\n  return ExpoP256.canUseBiometricAuthentication()\n}\n"]}