{"version":3,"file":"utils.js","sourceRoot":"","sources":["../../src/internal/utils.ts"],"names":[],"mappings":"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","sourcesContent":["import { Base64, type Bytes, Errors, Hex, PublicKey, Signature } from 'ox'\n\nimport type { createKeyPair, getKeyPair, sign } from '../P256'\n\n// ============= Type Adapters =============\n\n/**\n * Converts a native key pair response to the WebCryptoP256-compatible format.\n * @internal\n */\nfunction convertNativeKeyPairToWebCrypto(\n  privateKeyStorageKey: string,\n  nativeKeyPair: {\n    privateKey: string\n    publicKey: string\n  },\n): createKeyPair.ReturnType {\n  if (!nativeKeyPair.privateKey || !nativeKeyPair.publicKey) {\n    throw new InvalidKeyPairError()\n  }\n\n  console.info('[P256-NATIVE.convertNativeKeyPairToWebCrypto]:privateKeyStorageKey', privateKeyStorageKey)\n  return {\n    privateKeyStorageKey: privateKeyStorageKey,\n    publicKey: PublicKey.from(\n      Base64.toBytes(nativeKeyPair.publicKey),\n    ) as PublicKey.PublicKey,\n  }\n}\n\n/**\n * Adapts the native response from createKeyPair to the WebCryptoP256-compatible format.\n * Converts the base64 encoded public key to the ox PublicKey format.\n */\nexport function adaptCreateP256KeyPairReturnType(\n  privateKeyStorageKey: string,\n  nativeResponse: createKeyPair.NativeResponse,\n): createKeyPair.ReturnType {\n  return convertNativeKeyPairToWebCrypto(privateKeyStorageKey, nativeResponse)\n}\n\n/**\n * Adapts the native response from getKeyPair to the WebCryptoP256-compatible format.\n * Returns null if no key pair exists, otherwise converts to the WebCryptoP256 format.\n */\nexport function adaptGetP256KeyPairReturnType(\n  privateKeyStorageKey: string,\n  nativeResponse: getKeyPair.NativeResponse,\n): getKeyPair.ReturnType {\n  if (!nativeResponse) return null\n  return convertNativeKeyPairToWebCrypto(privateKeyStorageKey, nativeResponse)\n}\n\n/**\n * Adapts the native signature response to the WebCryptoP256-compatible format.\n * Extracts r and s values from the ASN.1 DER encoded signature.\n */\nexport function adaptSignWithP256KeyPairReturnType(\n  nativeResponse: sign.NativeResponse,\n): sign.ReturnType {\n  if (!nativeResponse?.signature) {\n    throw new InvalidSignatureError()\n  }\n  \n  const signatureBytes = Base64.toBytes(nativeResponse.signature)\n  const signatureHex = Hex.fromBytes(signatureBytes)\n\n  const { r, s } = Signature.fromDerHex(signatureHex)\n  return { r, s }\n}\n\n// ============= Payload Conversion =============\n\n/**\n * Converts a payload (Hex or Bytes) to a base64 string for native module consumption.\n * Handles both Uint8Array and hex string inputs.\n */\nexport function convertPayloadToBase64(payload: Hex.Hex | Bytes.Bytes): string {\n  if (payload instanceof Uint8Array) {\n    return Base64.fromBytes(payload)\n  }\n  return Base64.fromHex(payload)\n}\n\n\n// ============= Key Management =============\n\n/**\n * Storage key prefix for P256 keys\n */\nexport const P256_KEY_PREFIX = 'p256'\n\n/**\n * Generates a shorter unique storage key for a P256 key pair.\n * Combines timestamp base36 with random values for uniqueness.\n */\nexport function generateStorageKey(prefix: string = P256_KEY_PREFIX): string {\n  ensureValidKey(prefix)\n  const timestamp = Date.now().toString(36)\n  const random = Math.random().toString(36).slice(2, 6)\n\n  return `${prefix}-${timestamp}${random}`\n}\n\n/**\n * Validates that a key meets the required format.\n * Keys must not be empty and contain only alphanumeric characters, \".\", \"-\", and \"_\".\n */\nexport function ensureValidKey(key: string) {\n  if (!isValidKey(key)) {\n    throw new InvalidKeyFormatError(key)\n  }\n}\n\n/**\n * Tests if a key string matches a format compatible with the native key store.\n * @internal\n */\nfunction isValidKey(key: string) {\n  return typeof key === 'string' && /^[\\w.-]+$/.test(key)\n}\n\n// ============= Error Types =============\n\n/**\n * Thrown when a key pair is invalid or missing required components.\n */\nexport class InvalidKeyPairError extends Errors.BaseError {\n  override name = 'InvalidKeyPairError'\n  constructor() {\n    super('Invalid key pair: missing private key or public key')\n  }\n}\n\n/**\n * Thrown when a signature is invalid or missing.\n */\nexport class InvalidSignatureError extends Errors.BaseError {\n  override name = 'InvalidSignatureError'\n  constructor() {\n    super('Invalid signature: signature data is missing or malformed')\n  }\n}\n\n/**\n * Thrown when a key format is invalid.\n */\nexport class InvalidKeyFormatError extends Errors.BaseError {\n  override name = 'InvalidKeyFormatError'\n  constructor(key: string) {\n    super(\n      `Invalid key format: \"${key}\". Keys must not be empty and contain only alphanumeric characters, \".\", \"-\", and \"_\".`,\n    )\n  }\n}\n"]}