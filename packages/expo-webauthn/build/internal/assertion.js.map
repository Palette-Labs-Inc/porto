{"version":3,"file":"assertion.js","sourceRoot":"","sources":["../../src/internal/assertion.ts"],"names":[],"mappings":"AAAA,OAAO,EAAmC,aAAa,EAAE,MAAM,SAAS,CAAA;AACxE,OAAO,EAAE,sBAAsB,EAAE,oBAAoB,EAAE,MAAM,SAAS,CAAA;AA6CtE,qCAAqC;AAErC,sCAAsC;AACtC,MAAM,cAAe,SAAQ,aAAa;CAAG;AAE7C,8CAA8C;AAC9C,MAAM,mBAAoB,SAAQ,cAAc;CAAG;AAEnD,8CAA8C;AAC9C,MAAM,iBAAkB,SAAQ,cAAc;IAC5C,YAAY,KAAa;QACvB,KAAK,CAAC,2BAA2B,KAAK,EAAE,CAAC,CAAA;IAC3C,CAAC;CACF;AAED,0CAA0C;AAC1C,MAAM,UAAW,SAAQ,cAAc;IACrC,YAAY,EAAE,KAAK,KAAwB,EAAE;QAC3C,KAAK,CAAC,qCAAqC,EAAE,EAAE,KAAK,EAAE,CAAC,CAAA;IACzD,CAAC;CACF;AAED,mDAAmD;AAEnD;;;;GAIG;AACH,SAAS,eAAe,CAAC,OAGxB;IACC,IAAI,CAAC,OAAO,CAAC,SAAS,EAAE,CAAC;QACvB,MAAM,IAAI,iBAAiB,CAAC,WAAW,CAAC,CAAA;IAC1C,CAAC;IACD,IAAI,OAAO,CAAC,IAAI,KAAK,SAAS,EAAE,CAAC;QAC/B,MAAM,IAAI,iBAAiB,CAAC,MAAM,CAAC,CAAA;IACrC,CAAC;AACH,CAAC;AAED,mDAAmD;AAEnD;;;;GAIG;AACH,SAAS,yBAAyB,CAChC,SAAiC;IAEjC,QAAQ,SAAS,EAAE,CAAC;QAClB,KAAK,KAAK,CAAC;QACX,KAAK,KAAK,CAAC;QACX,KAAK,KAAK,CAAC;QACX,KAAK,QAAQ;YACX,OAAO,SAAS,CAAA;QAClB,KAAK,UAAU;YACb,OAAO,SAAS,CAAA;IACpB,CAAC;AACH,CAAC;AAED;;;GAGG;AACH,SAAS,gBAAgB,CAAC,UAAyC;IAKjE,OAAO;QACL,IAAI,EAAE,YAAY;QAClB,EAAE,EAAE,oBAAoB,CAAC,UAAU,CAAC,EAAE,CAAC;QACvC,UAAU,EAAE,UAAU,CAAC,UAAU;YAC/B,EAAE,GAAG,CAAC,yBAAyB,CAAC;aAC/B,MAAM,CAAC,CAAC,CAAC,EAAmC,EAAE,CAAC,CAAC,KAAK,SAAS,CAAC;KACnE,CAAA;AACH,CAAC;AAED;;;;GAIG;AACH,MAAM,UAAU,MAAM,CAAC,OAAuB;IAC5C,MAAM,SAAS,GAAG,OAAO,CAAC,SAAS,CAAA;IACnC,IAAI,CAAC,SAAS;QAAE,MAAM,IAAI,mBAAmB,CAAC,mBAAmB,CAAC,CAAA;IAElE,eAAe,CAAC;QACd,SAAS,EAAE,SAAS,CAAC,SAAS;QAC9B,IAAI,EAAE,SAAS,CAAC,IAAI;KACrB,CAAC,CAAA;IAEF,OAAO;QACL,SAAS,EAAE,oBAAoB,CAAC,SAAS,CAAC,SAAS,CAAC;QACpD,IAAI,EAAE,SAAS,CAAC,IAAI,IAAI,EAAE;QAC1B,gBAAgB,EAAE,SAAS,CAAC,gBAAgB,EAAE,GAAG,CAAC,gBAAgB,CAAC;QACnE,gBAAgB,EAAE,SAAS,CAAC,gBAAgB;QAC5C,OAAO,EAAE,SAAS,CAAC,OAAO;KAC3B,CAAA;AACH,CAAC;AAQD;;;;;;;;;;;;GAYG;AACH,MAAM,UAAU,KAAK,CAAC,QAAqB;IACzC,IAAI,CAAC;QACH,OAAO;YACL,EAAE,EAAE,QAAQ,CAAC,EAAE;YACf,KAAK,EAAE,sBAAsB,CAAC,QAAQ,CAAC,KAAK,CAAC;YAC7C,QAAQ,EAAE;gBACR,iBAAiB,EAAE,sBAAsB,CACvC,QAAQ,CAAC,QAAQ,CAAC,iBAAiB,CACpC;gBACD,cAAc,EAAE,sBAAsB,CACpC,QAAQ,CAAC,QAAQ,CAAC,cAAc,CACjC;gBACD,SAAS,EAAE,sBAAsB,CAAC,QAAQ,CAAC,QAAQ,CAAC,SAAS,CAAC;gBAC9D,UAAU,EAAE,QAAQ,CAAC,QAAQ,CAAC,UAAU;oBACtC,CAAC,CAAC,sBAAsB,CAAC,QAAQ,CAAC,QAAQ,CAAC,UAAU,CAAC;oBACtD,CAAC,CAAC,IAAI;aACT;YACD,IAAI,EAAE,YAAY;YAClB,uBAAuB,EAAE,QAAQ,CAAC,uBAAuB,IAAI,IAAI;YACjE,yBAAyB,EAAE,GAAG,EAAE,CAAC,CAAC,EAAE,CAAC;SACtC,CAAA;IACH,CAAC;IAAC,OAAO,KAAK,EAAE,CAAC;QACf,MAAM,IAAI,UAAU,CAAC,EAAE,KAAK,EAAE,KAAc,EAAE,CAAC,CAAA;IACjD,CAAC;AACH,CAAC","sourcesContent":["import { type AuthenticatorTransportType, WebAuthnError } from './types'\nimport { base64URLToArrayBuffer, bufferSourceToBase64 } from './utils'\nimport type {\n  AuthenticatorAssertionResponse,\n  AuthenticatorTransport,\n  PublicKeyCredential,\n  PublicKeyCredentialDescriptor,\n  UserVerificationRequirement,\n  CredentialRequestOptions as WebAuthnCredentialRequestOptions,\n} from './webauthn'\n\n// ============= Types =============\n\n/**\n * Options for requesting an existing credential\n * @internal\n */\ninterface AssertionOptions {\n  challenge: string\n  rpId: string\n  allowCredentials?: {\n    type?: 'public-key'\n    id: string\n    transports?: AuthenticatorTransportType[]\n  }[]\n  userVerification?: UserVerificationRequirement\n  timeout?: number\n}\n\n/**\n * Response from a successful credential assertion\n * @internal\n */\ninterface AssertionResponse {\n  id: string\n  rawId: string\n  response: {\n    authenticatorData: string\n    clientDataJSON: string\n    signature: string\n    userHandle?: string\n  }\n  type: 'public-key'\n  authenticatorAttachment?: string\n}\n\n// ============= Errors =============\n\n/** Base class for assertion errors */\nclass AssertionError extends WebAuthnError {}\n\n/** Thrown when request options are invalid */\nclass InvalidOptionsError extends AssertionError {}\n\n/** Thrown when a required field is missing */\nclass MissingFieldError extends AssertionError {\n  constructor(field: string) {\n    super(`Missing required field: ${field}`)\n  }\n}\n\n/** Thrown when assertion parsing fails */\nclass ParseError extends AssertionError {\n  constructor({ cause }: { cause?: Error } = {}) {\n    super('Failed to parse assertion response.', { cause })\n  }\n}\n\n// ============= Validation Functions =============\n\n/**\n * Validates required fields in request options\n * @throws {MissingFieldError} When a required field is missing\n * @internal\n */\nfunction validateOptions(options: {\n  challenge: BufferSource | undefined\n  rpId: string | undefined\n}): void {\n  if (!options.challenge) {\n    throw new MissingFieldError('challenge')\n  }\n  if (options.rpId === undefined) {\n    throw new MissingFieldError('rpId')\n  }\n}\n\n// ============= Conversion Functions =============\n\n/**\n * Maps a WebAuthn transport to an iOS authenticator transport\n * @see https://developer.apple.com/documentation/authenticationservices/asauthorizationsecuritykeypublickeycredentialdescriptor/transport\n * @internal\n */\nfunction mapAuthenticatorTransport(\n  transport: AuthenticatorTransport,\n): AuthenticatorTransportType | undefined {\n  switch (transport) {\n    case 'usb':\n    case 'nfc':\n    case 'ble':\n    case 'hybrid':\n      return transport\n    case 'internal':\n      return undefined\n  }\n}\n\n/**\n * Creates credential descriptor in iOS format\n * @internal\n */\nfunction createDescriptor(descriptor: PublicKeyCredentialDescriptor): {\n  type: 'public-key'\n  id: string\n  transports?: AuthenticatorTransportType[]\n} {\n  return {\n    type: 'public-key',\n    id: bufferSourceToBase64(descriptor.id),\n    transports: descriptor.transports\n      ?.map(mapAuthenticatorTransport)\n      .filter((t): t is AuthenticatorTransportType => t !== undefined),\n  }\n}\n\n/**\n * Creates assertion options in iOS format\n * @throws {InvalidOptionsError} When required fields are missing\n * @internal\n */\nexport function create(options: create.Options): create.ReturnType {\n  const publicKey = options.publicKey\n  if (!publicKey) throw new InvalidOptionsError('Missing publicKey')\n\n  validateOptions({\n    challenge: publicKey.challenge,\n    rpId: publicKey.rpId,\n  })\n\n  return {\n    challenge: bufferSourceToBase64(publicKey.challenge),\n    rpId: publicKey.rpId || '',\n    allowCredentials: publicKey.allowCredentials?.map(createDescriptor),\n    userVerification: publicKey.userVerification,\n    timeout: publicKey.timeout,\n  }\n}\n\nexport declare namespace create {\n  type Options = WebAuthnCredentialRequestOptions\n  type ReturnType = AssertionOptions\n  type ErrorType = InvalidOptionsError | MissingFieldError | Error\n}\n\n/**\n * Parses a native iOS assertion response into WebAuthn format\n *\n * @example\n * ```ts\n * const assertion = assertion.parse(nativeResponse)\n * // Returns WebAuthn formatted assertion\n * ```\n *\n * @param response - Native iOS assertion response\n * @returns WebAuthn formatted assertion\n * @throws {ParseError} If assertion cannot be parsed\n */\nexport function parse(response: parse.Input): parse.ReturnType {\n  try {\n    return {\n      id: response.id,\n      rawId: base64URLToArrayBuffer(response.rawId),\n      response: {\n        authenticatorData: base64URLToArrayBuffer(\n          response.response.authenticatorData,\n        ),\n        clientDataJSON: base64URLToArrayBuffer(\n          response.response.clientDataJSON,\n        ),\n        signature: base64URLToArrayBuffer(response.response.signature),\n        userHandle: response.response.userHandle\n          ? base64URLToArrayBuffer(response.response.userHandle)\n          : null,\n      },\n      type: 'public-key',\n      authenticatorAttachment: response.authenticatorAttachment || null,\n      getClientExtensionResults: () => ({}),\n    }\n  } catch (error) {\n    throw new ParseError({ cause: error as Error })\n  }\n}\n\nexport declare namespace parse {\n  type Input = AssertionResponse\n  type ReturnType = PublicKeyCredential & {\n    response: AuthenticatorAssertionResponse\n  }\n  type ErrorType = ParseError\n}\n"]}