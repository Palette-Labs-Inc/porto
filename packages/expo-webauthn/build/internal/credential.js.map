{"version":3,"file":"credential.js","sourceRoot":"","sources":["../../src/internal/credential.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  type AuthenticatorTransportType,\n  type CredentialUserEntity,\n  WebAuthnError,\n} from './types'\nimport { base64URLToArrayBuffer, bufferSourceToBase64 } from './utils'\nimport type {\n  AttestationConveyancePreference,\n  AuthenticatorAttestationResponse,\n  AuthenticatorSelectionCriteria,\n  AuthenticatorTransport,\n  PublicKeyCredential,\n  PublicKeyCredentialDescriptor,\n  PublicKeyCredentialParameters,\n  PublicKeyCredentialRpEntity,\n  CredentialCreationOptions as WebAuthnCredentialCreationOptions,\n} from './webauthn'\n\n// ============= Types =============\n\n/**\n * Options for creating a new credential\n * @internal\n */\ninterface CredentialCreationOptions {\n  rp: PublicKeyCredentialRpEntity\n  user: CredentialUserEntity\n  challenge: string\n  pubKeyCredParams?: {\n    type: 'public-key'\n    alg: number\n  }[]\n  timeout?: number\n  excludeCredentials?: {\n    type?: 'public-key'\n    id: string\n    transports?: AuthenticatorTransportType[]\n  }[]\n  authenticatorSelection?: AuthenticatorSelectionCriteria\n  attestation?: AttestationConveyancePreference\n}\n\n/**\n * Response from a successful credential creation\n * @internal\n */\ninterface CredentialAttestationResponse {\n  id: string\n  rawId: string\n  response: {\n    attestationObject: string\n    clientDataJSON: string\n  }\n  type: 'public-key'\n}\n\n// ============= Errors =============\n\n/** Base class for credential errors */\nclass CredentialError extends WebAuthnError {}\n\n/** Thrown when creation options are invalid */\nclass InvalidOptionsError extends CredentialError {}\n\n/** Thrown when a required field is missing */\nclass MissingFieldError extends CredentialError {\n  constructor(field: string) {\n    super(`Missing required field: ${field}`)\n  }\n}\n\n/** Thrown when credential parsing fails */\nclass ParseError extends CredentialError {\n  constructor({ cause }: { cause?: Error } = {}) {\n    super('Failed to parse credential response.', { cause })\n  }\n}\n\n/** Thrown when public key extraction fails */\nclass PublicKeyExtractionError extends CredentialError {\n  constructor({ cause }: { cause?: Error } = {}) {\n    super('Failed to extract public key from attestation object.', { cause })\n  }\n}\n\n// ============= Functions =============\n\n/**\n * Parses a SPKI (Subject Public Key Info) formatted public key from an attestation object.\n * The SPKI format is defined in RFC 5280 and is the standard format for X.509 certificates.\n *\n * @example\n * ```ts\n * const publicKeyBuffer = credential.parseSPKIFromAttestation(attestationObject)\n * ```\n *\n * @param attestationObject - Base64URL encoded attestation object\n * @returns ArrayBuffer containing the public key in SPKI format\n * @throws {PublicKeyExtractionError} If SPKI parsing fails\n */\nexport function parseSPKIFromAttestation(\n  attestationObject: parseSPKIFromAttestation.Input,\n): parseSPKIFromAttestation.ReturnType {\n  try {\n    // Decode attestation object\n    const data = new Uint8Array(base64URLToArrayBuffer(attestationObject))\n    const coordinateLength = 0x20 // 32 bytes for P-256\n    const cborPrefix = 0x58\n\n    // Find coordinate positions\n    const findStart = (key: number): number | null => {\n      const coordinate = new Uint8Array([key, cborPrefix, coordinateLength])\n      for (let i = 0; i < data.length - coordinate.length; i++)\n        if (coordinate.every((byte, j) => data[i + j] === byte))\n          return i + coordinate.length\n      return null\n    }\n\n    const xStart = findStart(0x21)\n    const yStart = findStart(0x22)\n\n    if (!xStart || !yStart) {\n      throw new Error(\n        'Could not find public key coordinates in attestation object',\n      )\n    }\n\n    // SPKI format prefix for P-256 public key\n    const spkiPrefix = new Uint8Array([\n      0x30,\n      0x59, // SEQUENCE, length 89\n      0x30,\n      0x13, // SEQUENCE, length 19\n      0x06,\n      0x07, // OBJECT IDENTIFIER, length 7\n      0x2a,\n      0x86,\n      0x48,\n      0xce,\n      0x3d,\n      0x02,\n      0x01, // OID 1.2.840.10045.2.1 (ecPublicKey)\n      0x06,\n      0x08, // OBJECT IDENTIFIER, length 8\n      0x2a,\n      0x86,\n      0x48,\n      0xce,\n      0x3d,\n      0x03,\n      0x01,\n      0x07, // OID 1.2.840.10045.3.1.7 (prime256v1)\n      0x03,\n      0x42, // BIT STRING, length 66\n      0x00, // No unused bits\n      0x04, // Uncompressed point format\n    ])\n\n    // Combine into final public key format\n    const publicKeyBytes = new Uint8Array(\n      spkiPrefix.length + coordinateLength * 2,\n    )\n    publicKeyBytes.set(spkiPrefix)\n    publicKeyBytes.set(\n      data.slice(xStart, xStart + coordinateLength),\n      spkiPrefix.length,\n    )\n    publicKeyBytes.set(\n      data.slice(yStart, yStart + coordinateLength),\n      spkiPrefix.length + coordinateLength,\n    )\n\n    return publicKeyBytes.buffer\n  } catch (error) {\n    throw new PublicKeyExtractionError({ cause: error as Error })\n  }\n}\n\nexport declare namespace parseSPKIFromAttestation {\n  type Input = string\n  type ReturnType = ArrayBuffer\n  type ErrorType = PublicKeyExtractionError\n}\n\n// ============= Validation Functions =============\n\n/**\n * Validates that the algorithm is supported\n * @throws {InvalidOptionsError} When algorithm is not ES256 (-7)\n * @internal\n */\nfunction validateAlgorithm(alg: number): void {\n  if (alg !== -7) {\n    // ES256\n    throw new InvalidOptionsError('Unsupported algorithm', {\n      metaMessages: [\n        'Only ES256 (-7) is supported by AuthenticationServices.',\n        'See https://developer.apple.com/documentation/authenticationservices/ascosealgorithmidentifier',\n      ],\n    })\n  }\n}\n\n/**\n * Validates required fields in creation options\n * @throws {MissingFieldError} When a required field is missing\n * @internal\n */\nfunction validateOptions(options: {\n  rp: PublicKeyCredentialRpEntity | undefined\n  user: PublicKeyCredentialUserEntity | undefined\n  challenge: BufferSource | undefined\n}): void {\n  if (!options.rp?.name) {\n    throw new MissingFieldError('rp.name')\n  }\n  if (!options.user?.name) {\n    throw new MissingFieldError('user.name')\n  }\n  if (!options.challenge) {\n    throw new MissingFieldError('challenge')\n  }\n}\n\n// ============= Conversion Functions =============\n\n/**\n * Maps a WebAuthn transport to an iOS authenticator transport\n * @see https://developer.apple.com/documentation/authenticationservices/asauthorizationsecuritykeypublickeycredentialdescriptor/transport\n * @internal\n */\nfunction mapAuthenticatorTransport(\n  transport: AuthenticatorTransport,\n): AuthenticatorTransportType | undefined {\n  switch (transport) {\n    case 'usb':\n    case 'nfc':\n    case 'ble':\n    case 'hybrid':\n      return transport\n    case 'internal':\n      return undefined\n  }\n}\n\n/**\n * Creates credential parameters in iOS format\n * @throws {InvalidOptionsError} When algorithm is not ES256 (-7)\n * @internal\n */\nfunction createParameters(params: PublicKeyCredentialParameters): {\n  type: 'public-key'\n  alg: number\n} {\n  validateAlgorithm(params.alg)\n  return {\n    type: 'public-key' as const,\n    alg: params.alg,\n  }\n}\n\n/**\n * Creates credential descriptor in iOS format\n * @internal\n */\nfunction createDescriptor(descriptor: PublicKeyCredentialDescriptor): {\n  type: 'public-key'\n  id: string\n  transports?: AuthenticatorTransportType[]\n} {\n  return {\n    type: 'public-key',\n    id: bufferSourceToBase64(descriptor.id),\n    transports: descriptor.transports\n      ?.map(mapAuthenticatorTransport)\n      .filter((t): t is AuthenticatorTransportType => t !== undefined),\n  }\n}\n\n/**\n * Creates credential options in iOS format\n * @throws {InvalidOptionsError} When required fields are missing\n * @internal\n */\nexport function create(options: create.Options): create.ReturnType {\n  const publicKey = options.publicKey\n  if (!publicKey) throw new InvalidOptionsError('Missing publicKey')\n\n  validateOptions({\n    rp: publicKey.rp,\n    user: publicKey.user,\n    challenge: publicKey.challenge,\n  })\n\n  return {\n    rp: publicKey.rp,\n    user: {\n      id: bufferSourceToBase64(publicKey.user.id),\n      name: publicKey.user.name,\n      displayName: publicKey.user.displayName,\n    },\n    challenge: bufferSourceToBase64(publicKey.challenge),\n    pubKeyCredParams: publicKey.pubKeyCredParams?.map(createParameters),\n    timeout: publicKey.timeout,\n    excludeCredentials: publicKey.excludeCredentials?.map(createDescriptor),\n    authenticatorSelection: publicKey.authenticatorSelection,\n    attestation: publicKey.attestation,\n  }\n}\n\nexport declare namespace create {\n  type Options = WebAuthnCredentialCreationOptions\n  type ReturnType = CredentialCreationOptions\n  type ErrorType = InvalidOptionsError | MissingFieldError | Error\n}\n\n/**\n * Parses a native iOS credential response into WebAuthn format\n *\n * @example\n * ```ts\n * const credential = credential.parse(nativeResponse)\n * // Returns WebAuthn formatted credential\n * ```\n *\n * @param response - Native iOS credential response\n * @returns WebAuthn formatted credential\n * @throws {ParseError} If credential cannot be parsed\n */\nexport function parse(response: parse.Input): parse.ReturnType {\n  try {\n    const publicKeyBuffer = parseSPKIFromAttestation(\n      response.response.attestationObject,\n    )\n\n    return {\n      id: response.id,\n      rawId: base64URLToArrayBuffer(response.rawId),\n      response: {\n        attestationObject: base64URLToArrayBuffer(\n          response.response.attestationObject,\n        ),\n        clientDataJSON: base64URLToArrayBuffer(\n          response.response.clientDataJSON,\n        ),\n        getAuthenticatorData: () => {\n          const data = new Uint8Array(\n            base64URLToArrayBuffer(response.response.attestationObject),\n          )\n          // Skip CBOR header and find authenticator data\n          const authenticatorData = data.slice(data[0] === 0x58 ? 2 : 1)\n          return authenticatorData.buffer\n        },\n        getPublicKey: () => publicKeyBuffer,\n        getPublicKeyAlgorithm: () => -7, // ES256\n        getTransports: () => [],\n      },\n      type: 'public-key',\n      authenticatorAttachment: null,\n      getClientExtensionResults: () => ({}),\n    }\n  } catch (error) {\n    throw new ParseError({ cause: error as Error })\n  }\n}\n\nexport declare namespace parse {\n  type Input = CredentialAttestationResponse\n  type ReturnType = PublicKeyCredential & {\n    response: AuthenticatorAttestationResponse\n  }\n  type ErrorType = ParseError | parseSPKIFromAttestation.ErrorType\n}\n"]}